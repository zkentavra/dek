Предметна область . Аналіз предметної області. Навести приклад.
Поняття предметної області бази даних є одним з базових понять інформатики і не має точного визначення. Його використання в контексті ІС передбачає існування стійкої в часі співвіднесеності між іменами, поняттями і певними реаліями зовнішнього світу, що не залежить від самої ІС і її кола користувачів. Таким чином, введення в розгляд поняття предметної області бази даних обмежує і робить доступним для огляду простір інформаційного пошуку в ІС і дозволяє виконувати запити за кінцевий час.
Етапи проектування БД. 
Перед тим як створювати таблиці, форми та інші об'єкти, потрібно задати структуру бази даних. Добра структура бази даних є основою для створення адекватної вимогам, ефекти¬вної бази даних. Сам процес проектування бази даних являє со¬бою складний процес проектування відображення опису предме¬тної області у схему внутрішньої моделі даних. 
Визначення мети створення бази даних. На першому ета¬пі проектування бази даних необхідно визначити мету створення бази даних, основні її функції та інформацію, яку вона повинна містити. Тобто потрібно визначити основні теми таблиць бази даних та інформацію, що міститимуть поля таблиць.
Визначення таблиць, які повинні містити база даних. Одним із найскладніших етапів у процесі проектування бази да¬них є розробка таблиць, тому що результати, які повинна видава¬ти база даних (звіти, вихідні форми тощо), не завжди дають по¬вне уявлення про структуру таблиці. У разі проектування таблиць зовсім не обов'язково використовувати СУБД. Спочатку краще розробити структуру на папері.
Визначення необхідних у таблиці полів. Кожна таблиця містить інформацію на окрему тему, а кожне поле в таблиці міс¬тить окремі дані по темі таблиці. Наприклад, у таблиці з даними про клієнта можуть бути поля з назвою компанії, адресою, міс¬том, країною і номером телефону.
Задання індивідуального значення кожному полю. З тим, щоб СУБД могла зв'язати дані з різних таблиць, наприклад дані про клієнта і його замовлення, кожна таблиця повинна містити поле чи набір полів, що задаватимуть індивідуальне значення кожного запису в таблиці. Таке поле чи набір полів називають основним ключем.
Визначення зв'язків між таблицями. Після розподілу да¬них по таблицях і визначення ключових полів необхідно вибрати схему для зв'язку даних у різних таблицях. Для цього потрібно визначити зв'язки між таблицями.
Відновлення структури бази даних. Після проектування таблиць, полів і зв'язків необхідно ще раз переглянути структуру бази даних і виявити можливі недоліки. Бажано це зробити на даному етапі, поки таблиці не заповнені даними. Для перевірки необхідно створити кілька таблиць, ви¬значити зв'язки між ними та ввести кілька записів у кожну таб¬лицю, потім подивитися, чи відповідає база даних поставленим вимогам. 
Додавання даних і створення інших об'єктів бази даних. Якщо структури таблиць відповідають поставленим вимогам, то можна вводити всі дані. Потім можна створювати будь-які запи¬ти, форми, звіти, макроси та модулі.
Строковий  тип даних мови SQL. Навести приклади.
Дані строкового типу являють собою послідовність рядків символів. Строкові дані можуть бути задані як з визначеною довжиною (ключові слова char або varchar (довжина рядка)), так і без вказівки довжини (ключове слово long varchar) для подання рядків довільної довжини. Тип даних varchar2 визначає рядок символів змінної довжини, що має максимальний розмір size. На відміну від строкового типу з визначеною довжиною, з рядками long varchar не допускаються операції порівняння, і вони не можуть бути використані у виразах і як аргументи більшості убудованих функцій. Рядки останнього типу можуть застосовуватися для збереження бітових образів. Стандарт SQL-92 не має типу long varchar й varchar.
Зверніть увагу на тип даних varchar2. Він, так само як і тип даних char, призначений для подання алфавітно-цифрових даних. Але він має формат змінної довжини. Останнє означає, що довжина колонки такого типу дорівнює числу символів у ній, у той час як колонка типу char використовує весь виділений для неї простір.
Числовий тип даних мови SQL. Навести приклади.
Існує два типи числових даних. Цілі й речовинні. Вони є об'єктом математичної обробки. Строкові числові дані, у яких єдино припустимими символами є цифри (наприклад, номери банківських рахунків).
Числові типи даних призначені для подання цілих чисел, чисел з десятковою крапкою й чисел із плаваючою крапкою. Будь-яке подання чисел задається своєю точністю й масштабом. Для подання цілих чисел використовуються типи interger (точність 10 значущих цифр) і smallint (точність 5 значущих цифр).
Для подання чисел з фіксованою десятковою крапкою використовуються типи number (точність, масштаб) (для чисел з точністю до 15 значущих цифр) і decimal (точність, масштаб) (для чисел заданої точності до 15 значущих цифр). Якщо вказати для колонки тип number без завдання масштабу, максимальне число значущих цифр для Oracle буде 105. Замість завдання точності й масштабу може бути зазначений символ *. Це буде еквівалентно завданню простого типу number. Розходження між цими типами даних полягає в тому, що для типу number немає необхідності стежити за точністю при виконанні операцій.
Для подання чисел із плаваючою крапкою в SQL передбачені такі типи даних:
Double Precision - для чисел з точністю від 22 до 53 значущих цифр;
Float (точність) - для подання чисел з точністю від 1 до 21 значущої цифри;
Real - для чисел із точністю за замовчуванням (залежить від конкретної реалізації).
Тип даних для подання дати й часу. Навести приклади.
Тип даних для подання дати й часу відсутній у стандарті SQL. Звичайно в конкретних діалектах SQL використовуються три типи для подання таких даних:
datestamp (timestamp) - для подання дати й часу;
date - для подання дати;
time - для подання часу.
Будь-який діалект SQL підтримують три загальних типи даних: строковий, числовий й тип для подання дати й часу. Завдання типу даних визначає значення й довжину даних, а також формат їхнього подання при візуалізації.
Для всіх типів даних визначено так зване нуль-значення, що вказує на відсутність даних у колонку зазначеного типу, тобто та обставина, що значення даних у сучасний момент часу невідомо.
Характеристика інформаційної, логічної й фізичної моделі даних
Інформаційна модель даних призначена для подання семантики ПО у термінах суб'єктивних засобів опису - сутностей, атрибутів, ідентифікаторів сутностей, супертипів, підтипів і т.д.
У ході контролю якості основними моментами діяльності є контроль ER-діаграм і контроль діаграм функціональної моделі ПО. На підставі ER-діаграм створюється логічна модель реляційної БД; на підставі діаграм функціональної моделі розробляється серверний код і проектуються модулі додатків БД.
Інформаційна модель даних відбиває потреби системи в даних і зв'язку між даними з погляду їх споживачів - користувачів; логічна модель даних є незалежним логічним поданням даних; фізична модель даних містить визначення всіх реалізованих об'єктів у конкретній БД для конкретної СКБД
Перша нормальна форма (1NF). Приклад використання.
Перша нормальна форма (1НФ, 1NF) утворює ґрунт для структурованої схеми баз даних:
Кожна таблиця повинна мати основний ключ: мінімальний набір колонок, які ідентифікують запис.
Уникнення повторень груп (категорії даних, що можуть зустрічатись різну кількість раз в різних записах) правильно визначаючи неключові атрибути.
Атомарність: кожен атрибут повинен мати лише одне значення, а не множину значень.
Початкова не нормалізована таблиця:
Співробітник	Номер телефону
Іваненко І. І.	283-56-82
390-57-34
Петренко П. П.	708-62-34
Співробітник	Номер телефону
Іваненко І. І.	283-56-82
Іваненко І. І.	390-57-34
Петренко П. П.	708-62-34
Таблиця, приведена до 1NF:
Друга нормальна форма (2NF). Приклад використання.
Друга нормальна форма (2НФ, 2NF) — нормальна форма, що використовується для нормалізації баз даних. 2НФ первісно була визначена 1971 року Едгаром Коддом.[1] Щоб бути в другій нормальній формі, таблиця, що знаходиться в першій нормальній формі, має відповідати додатковим критеріям. А саме: 1НФ таблиця знаходиться в 2НФ тоді й лише тоді, коли для будь-якого потенційного ключа K і будь-якого атрибута A, який не є частиною потенційного ключа, A залежить саме від цілого потенційного ключа, а не від його частини.
Тобто, 1НФ таблиця знаходиться в 2НФ тоді і тільки тоді, коли всі її неключові атрибути функціонально залежні від цілих потенційних ключів.
У разі, якщо 1НФ таблиця не має складних потенційних ключів (таких, що складаються більш ніж з одного атрибута), тоді вона автоматично знаходиться в 2НФ.
 
Ані {Працівник} ані {Вміння} не є потенційними ключами для таблиці. «Працівник» може мати декілька вмінь, а «Вміння» може з'являтись у більше ніж одного Працівника. Саме складний ключ {Працівник, Вміння} підходить як потенційний ключ для таблиці.
Інші атрибути, «Поточне місце роботи», залежні від частини потенційного ключа, від Працівника. Тобто таблиця не в 2НФ. Існує надлишковість у представленні атрибута «Поточне місце роботи»: тричі повторюється те, що Палій працює на Бузковому провулку, 7, і двічі, що Мамай працює на проспекті Троянд, 49. Ця надлишковість робить таблицю вразливою для аномалій оновлення: це, наприклад, можливість оновити місце роботи Палія на його записах про «Друкування» і «Стенографію» і не оновити запис про «Мосяжництво». Отримані дані будуть припускати суперечливі відповіді на питання «Де працює Палій?»

Варіант у 2НФ для цього набору даних буде містити дві таблиці: «Працівник» з потенційним ключем {Працівник}, «Вміння працівників» з потенційним ключем {Працівник, Вміння}:
 
Третя нормальна форма (3NF). Приклад використання.
Третя нормальна форма (3НФ) — нормальна форма використовна в нормалізації баз даних. 3НФ первісно була визначена 1971 року Едгаром Коддом.[1] За Коддом таблиця знаходиться в 3НФ тоді й лише тоді, коли виконуються наступні умови:
Відношення R (таблиця) знаходиться в 2НФ
Кожен неключовий атрибут відношення R нетранзитивно (безпосередньо) залежить від кожного потенційного ключа в R.
Неключовий атрибут R — атрибут, що не є частиною будь-якого потенційного ключа.[2] Транзитивною називають таку функціональну залежність, в якій X > Z (X визначає Z) непрямо, а через X > Y і Y > Z (і неправильно, що Y > X).[3]
Інше визначення 3НФ тотожне до визначення Кодда, 1982 року дав Карло Заніоло. Це визначення стверджує, що таблиця в 3НФ тоді й лише тоді, коли для кожної її функціональної залежності X > A, вірна хоча б одна з наступних умов:
X містить A (тоді X > A це тривіальна функціональна залежність), або
X це суперключ, або
A-X, різниця множин A і X це ключовий атрибут (тобто, A-X міститься в потенційному ключі)[4]
 
Кожен співробітник відноситься виключно до одного відділу; кожен відділ має єдиний телефон. Атрибут Співробітник є первинним ключем. Особистих телефонів у співробітників немає, і телефон співробітника залежить виключно від відділу.
У прикладі існують такі функціональні залежності: Співробітник > Відділ, Відділ > Телефон Працівник > Телефон.
Мінлива відносини R1 знаходиться в другій нормальній формі, оскільки кожен атрибут має непріводімим функціональну залежність від потенційного ключа Співробітник.
Залежність Співробітник > Телефон є транзитивною, отже, ставлення чи не знаходиться в третій нормальній формі.
В результаті поділу R1 виходять дві змінні відносини, що знаходяться в 3NF:
 
Поняття реляційної бази даних  Ключ, ключове поле таблиці
Реляційна (від анг. relation) база даних  — це тип бази даних, що зберігає інформацію в електронних таблицях і здійснює пошук даних в одній таблиці на підставі визначених ключових полів іншої таблиці. Інакше кажучи, реляційна база даних — це база даних, яка сприймається користувачем як набір нормалізованих відношень різного ступеня. Під нормалізацією розуміється, що в кожній таблиці БД не повинно бути повторюваних полів; в кожній таблиці повинен бути унікальний ідентифікатор (первинний ключ); зміна знвчень в полях таблиці не повинна впливати на інформацію в інших полях (крім змін у полях ключа). Первинний ключ — це одне або кілька полів (стовпців), комбінація значень яких однозначно визначає кожний запис у таблиці. Первинний ключ не допускає значень Null і завжди повинен мати унікальний індекс. Первинний ключ використовується для зв’язування таблиці з зовнішніми ключами в інших таблицях.
Зовнішній (вторинний) ключ — це одне або кілька полів (стовпців) у таблиці, що містять посилання на поле або поля первинного ключа в іншій таблиці. Зовнішній ключ визначає спосіб об’єднання таблиць.

Опишіть поняття тестування і документування.
Тестування (software testing) - діяльність, що виконується для оцінки та вдосконалення програмного забезпечення. Ця діяльність,в загальному випадку, базується на виявленні дефектів і проблем в
програмних системах.Тестування програмних систем складається з динамічної
верифікації поведінки програм на кінцевому (обмеженому) наборітестів (set of test cases), обраних відповідним чином з зазвичайвиконуваних дій прикладної області і забезпечують перевірку
відповідності очікуваному поведінки системи.
•	відповідність вимогам, якими керувалися проектувальники та розробники
•	правильна відповідь для усіх можливих вхідних даних
•	виконання функцій за прийнятний час
•	практичність
•	сумісність з програмним забезпеченням та операційними системами
•	відповідність задачам замовника.
Верифікація (Verification) — це процес оцінки системи або її компонентів з метою визначити чи задовольняють результати поточного етапу розробки умовам, сформованим на початку цього етапу. Тобто чи виконуються цілі, терміни, завдання з розробки проекту, визначені на початку поточної фази. Валідація (Validation) — це визначення відповідності розроблюваного програмного забезпечення між очікуваннями і потребами користувача, вимогам до системи.
Документування результатів тестування згідно з чинним стандартом ANSI / IEEE 829 включає: • опис завдань, призначення і зміст програмних систем, а також перелік функцій відповідно до вимог замовника; • технології розробки системи; • планів тестування різних об'єктів, необхідних ресурсів, відповідних фахівців для проведення тестування і технологічних способів; • тестів, контрольних прикладів, критеріїв та обмежень, оцінки результатів програмного продукту, а також процесу тестування; • обліку процесу тестування, складання звітів про аномальні події, відмовах і дефекти в підсумковому документі системи.
Визначте техніки тестування.
. Техніки, що базуються на досвіді й інтуїції (Based on the software engineer's intuition and experience) 9.1.1. Спеціалізоване тестування (Ad hoc testing) Можливо, найбільш широко практикується техніка. Тести грунтуються на досвіді, інтуїції і знаннях інженера, який розглядає проблему з точки зору тих, що були раніше аналогій. Даний вид тестування може бути корисний для ідентифікації тих тестів, які не охоплюються рассматрівавшімеся вище більш формалізованими техніками. 9.1.2. Дослідне тестування (Exploratory testing) Таке тестування визначається як одночасне навчання, проектування тесту і його виконання. Даний вид тестування заздалегідь не визначається в плані тестування і такі тести створюються, виконуються і модифікуються динамічно, в міру необхідності. Ефективність дослідницьких тестів безпосередньо залежить від знань інженера, що формуються на основі поведінки тестування продукту в процесі проведення тестування, ступеня знайомства з додатком, платформою, типами можливих збоїв і дефектів, ризиками, асоційованими з конкретним продуктом і т.п. 9.2. Техніки, що базуються на специфікації (Specification-based techniques)
9.2.1. Еквівалентне розділення (Equivalence partitioning) Розглянута область програми поділяється на колекцію наборів або еквівалентних класів, які вважаються еквівалентними з точки зору розглянутих зв'язків та характеристик . Репрезентативне набір тестів (іноді - тільки один тест) формується з тестів еквівалентних класів (або наборів класів). 186 9.2.2. Аналіз граничних значень (Boundary-value analysis) Тести будуються з орієнтацією на використання тих величин, які визначають граничні характеристики тестованої системи. Розширення цієї техніки є тести оцінки живучості (robustness testing) системи, що проводяться з величинами, що виходять за рамки специфіковані меж значень. 9.2.3. Таблиці прийняття рішень (Decision table) Такі таблиці представляють логічні зв'язки між умовами (можуть розглядатися в якості "Входів") і діями (можуть розглядатися як "виходи"). Набір тестів будується послідовним розглядом всіх можливих крос-зв'язків в такій таблиці. 9.2.4. Тести на основі скінченого автомату (Finite-state machine-based) Будуються як комбінація тестів для всіх станів і переходів між станами, представлених у відповідній моделі (переходів і станів програми).
9.3. Техніки, орієнтовані на код 187 (Code-based techniques) 9.3.1. Тести, що базуються на блок-схемі (Control-flow-based criteria) Набір тестів будується виходячи з покриття всіх умов і рішень блок-схеми. В якійсь мірі нагадує тести на основі кінцевого автомата. Відмінність - у джерелі набору тестів. Максимальна віддача від тестів на основі блок-схеми виходить коли тести покривають різні шляху блок-схеми - по-суті, сценарії потоків робіт (поведінки) тестованої системи. Адекватність таких тестів оцінюється як відсоток покриття всіх можливих шляхів блок- схеми.
Охарактеризуйте функціональні критерії тестів.
Функціональний критерій - найважливіший для програмної індустрії критерій тестування. Він забезпечує, перш за все, контроль ступеня виконання вимог замовника в програмному продукті. Оскільки вимоги формулюються до продукту в цілому, вони відображають взаємодію тестованого додатки з оточенням. При функціональному тестуванні переважно використовується модель «чорного ящика». Проблема функціонального тестування - це, перш за все, трудомісткість; справа в тому, що документи, які фіксують вимоги до програмного виробу (Software requirement specification, Functional specification і т.п.), як правило, досить об'ємні, тим не менш, відповідна перевірка повинна бути всеосяжною.
Нижче наведені приватні види функціональних критеріїв.
•	Тестування пунктів специфікації - набір тестів в сукупності має забезпечити перевірку кожного тестованого пункту не менше одного разу. Специфікація вимог може містити сотні і тисячі пунктів вимог до програмного продукту і кожне з цих вимог при тестуванні повинно бути підтверджено відповідно до критерію не менш ніж одним тестом.
•	Тестування класів вхідних даних - набір тестів в сукупності має забезпечити перевірку представника кожного класу вхідних даних не менше одного разу. при створенні тестів класи вхідних даних зіставляються з режимами використання тестованого компонента чи підсистеми додатки, що помітно скорочує варіанти перебору, що враховуються при розробці тестових наборів. Слід зауважити, що, перебираючи відповідно до критерію величини вхідних змінних (наприклад, різні файли - джерела вхідних даних), ми змушені застосовувати потужні тестові набори. Дійсно, поряд з обмеженнями на величини вхідних даних, існують обмеження на величини вхідних даних у всіляких комбінаціях, у тому числі перевірка реакцій системи на появу помилок у значеннях або структурах вхідних даних. Облік цього різноманіття - процес трудомісткий, що створює складнощі для застосування критерію.
•	Тестування правил - набір тестів в сукупності має забезпечити перевірку кожного правила, якщо вхідні і вихідні значення описуються набором правил деякої граматики. Слід зауважити, що граматика має бути досить простий, щоб трудомісткість розробки відповідного набору тестів була реальною (вписувалася у строки і штат фахівців, виділених для реалізації фази тестування).
•	Тестування класів вихідних даних - набір тестів в сукупності має забезпечити перевірку представника кожного вихідного класу, за умови, що вихідні результати заздалегідь расклассифицировать, причому окремі класи результатів вказують, в тому числі обмеження на ресурси або на час (time out). 
При створенні тестів класи вихідних даних зіставляються з режимами використання тестованого компонента чи підсистеми, що помітно скорочує варіанти перебору, що враховуються при розробці тестових наборів.
•	Тестування функцій - набір тестів в сукупності має забезпечити перевірку кожної дії, що реалізується модулем, що тестується, не менше одного разу. Дуже популярний на практиці критерій, який, однак, не забезпечує покриття частини функціональності тестованого компонента, пов'язаної із структурними та поведінковими властивостями, опис яких не зосереджена в окремих функціях (тобто опис розосереджено по компоненту).
Охарактеризуйте структурні критерії тестів.
Структурні критерії (клас I).
Структурні критерії використовують модель програми у вигляді "білого ящика", що передбачає знання вихідного тексту програми або специфікації програми у вигляді потокового графа управління.Структурна інформація зрозуміла й доступна розробникам підсистем і модулів програми, тому даний клас критеріїв часто використовується на етапах модульного та інтеграційного тестування.
Структурні критерії базуються на основних елементах УДП, операторах, гілках і шляхах.
•	Умова критерію тестування команд (критерій С0) - набір тестів в сукупності має забезпечити проходження кожної команди не менше одного разу. Це слабкий критерій, використовується у великих програмних системах, де інші критерії застосувати неможливо.
•	Умова критерію тестування гілок (критерій С1) - набір тестів в сукупності має забезпечити проходження кожної гілки не менше одного разу. Це досить сильний і при цьому економічний критерій. Цей критерій часто використовується в системах автоматизованого тестування.
•	Умова критерію тестування шляхів (критерій С2) - набір тестів в сукупності повинен забезпечити проходження кожного шляху не менше одного разу. Якщо програма містить цикл (особливо з неявно заданої кількості ітерацій), то число ітерацій обмежується константою (часто - 2, або числом класів вихідних шляхів).
Структурні критерії не перевіряють відповідність специфікації, якщо воно не відображено у структурі програми.
Опишіть типи програмних помилок.
Програм без помилок не існує. Практика доводить, що винуватцями помилок у програмах найчастіше бувають самі програмісти. Один із загальних законів практичного програмування полягає в тому, що жодна програма не дає бажаних результатів при першій спробі трансляції та виконання. Певне уявлення про справжні причини появи помилок у роботі програми дає таке процентне співвідношення джерел збоїв:
Вхідні дані	1%
Помилки користувача	5%
Апаратура	1%
Системне програмне забезпечення	3%
Розробка системи	15%
Програмування	75%
     Програміст повинен не тільки писати ефективні програми, але і знаходити в них усілякі помилки. Сучасна практика навчання програмуванню орієнтована, в основному, тільки на виконання програмістом першої половини своєї роботи. Це все одно, як навчати льотчика тільки зльоту, припускаючи, що з посадкою машини він якось розбереться сам, якщо буде виконувати всі операції зльоту в зворотному порядку.
     Існують два типи програмних помилок:
     синтаксичні помилки - виникають через порушення правил мови програмування. Такі помилки зазвичай виявляються під час компіляції. Можуть бути виключені порівняно легко. Навіть якщо не переглядати текст програми можна бути впевненим, що компілятор на стадії трансляції знайде помилки і видасть відповідні попередження. Фактично пошук помилок здійснює компілятор, а їхнє виправлення - програміст;
     семантичні (логічні) помилки - ті, що призводять до некоректних обчислень або помилок під час виконання (run-time error). Семантичні помилки усувають зазвичай за допомогою виконання програми з ретельно підібраними перевірочними даними, для яких відома правильна відповідь.
Опишіть методи тестування.
Тестування «білого ящика"
Відома: внутрішня структура програми.
Досліджуються: внутрішні елементи програми і зв'язку між ними.
Об'єктом тестування тут є не зовнішнє, а внутрішнє поведінку програми. Перевіряється коректність побудови всіх елементів програми і правильність їх взаємодії один з одним. Зазвичай аналізуються керуючі зв'язку елементів, рідше - інформаційні зв'язки. Тестування за принципом "білого ящика" характеризується ступенем, в якій тести виконують або покривають логіку (вихідний текст) програми. Повне тестування важко.
Особливості тестування "білого ящика".
Зазвичай тестування "білого ящика" засноване на аналізі керуючої структури програми. Програма вважається повністю перевіреної, якщо проведено вичерпне тестування маршрутів (шляхів) її графа управління.
У цьому випадку формуються тестові варіанти, в яких:
•	Гарантується перевірка всіх незалежних маршрутів програми.
•	Знаходяться гілки True, False для всіх логічних рішень.
•	Виконуються всі цикли (в межах їх кордонів і діапазонів).
•	Аналізується правильність внутрішніх структур даних.
Метод «сірого ящику» - комбінований метод "чорної скриньки" і "прозорого ящика", заснований на влаштування вхідної області функції на підобласті виявлення помилок. Підобласть містить однорідні елементи, які все обробляються коректно або некоректно. Для тестування підобласті проводиться виконання програми на одному з елементів цієї області. Передумови функціонального тестування: • коректне оформлення вимог і обмежень до якості ПЗ; • коректне опис моделі функціонування ПЗ в середовищі експлуатації у замовника; • адекватність моделі ПО заданому класу.

Охарактеризуйте тестування «білого ящика».
Метод "білого ящика" дозволяє дослідити внутрішню структуру програми, причому виявлення всіх помилок у програмі є критерієм вичерпного тестування маршрутів потоків (графа) передач управління, серед яких розглядаються: • (а) критерій покриття операторів - набір тестів у сукупності повинен забезпечити проходження кожного оператора не менееодного рази; • (б) критерій тестування гілок (відомий як покриття рішень або покриття переходів) - набір тестів у сукупності повинен забезпечити проходження кожної гілки і виходу, принаймні, один раз. Критерій (б) відповідає простому структурному тесту і найбільш поширений на практиці. Для задоволення цього критерію необхідно побудувати систему шляхів, що містить всі гілки програми. Знаходження такого оптимального покриття в деяких випадках здійснюється просто, а в інших є більш складним завданням. Тестування за принципом "білого ящика" орієнтоване на перевірку проходження всіх шляхів програм за допомогою застосування подорожнього та імітаційного тестування. "Білий ящик" базується на структурі програми, у випадку "чорного ящика", про структуру програми нічого невідомо. Для виконання тестування за допомогою цих "скриньок" відомими вважаються виконувані функції, входи (вхідні дані) і виходи (вихідні дані), а також логіка обробки, представлені в документації
Охарактеризуйте тестування «чорного ящика».
Мета динамічного тестування програм за принципом "чорного ящика" - виявлення одним тестом максимального числа помилок з використанням невеликого підмножини можливих вхідних даних. Методи "чорного ящика" забезпечують: • еквівалентне розбиття; • аналіз граничних значень; • застосування функціональних діаграм, які в поєднанні з реверсивним аналізом дають досить повну інформацію про функціонування програми, що тестується. Еквівалентна розбиття полягає в розбитті вхідний області даних програми на кінцеве число класів еквівалентності так, щоб кожний тест, що є представником деякого класу, був еквівалентний будь-якого іншого тесту цього класу. Класи еквівалентності виділяються шляхом перебору вхідних умов і розбиття їх на дві або більше груп. При цьому розрізняють два типи класів еквівалентності: правильні, які визначають вхідні дані для програми, і неправильні, засновані на завданні помилкових вхідних значень. Розробка тестів методом еквівалентного роздроблення здійснюється у два етапи: - виділення класів еквівалентності і - побудова тестів. 174 При побудові тестів, заснованих на виборі вхідних даних, проводиться символічне виконання програми. Отже, методи тестування за принципом "чорного ящику" або "чорної скриньки" використовуються для тестування функцій, реалізованих у програмі, шляхом перевірки невідповідності між реальною поведінкою функцій і очікуваним поведінкою з урахуванням специфікацій вимог. Під час підготовки до цього тестування будуються таблиці умов, причинно-наслідкові графи і області розбивки. Крім того, готуються тестові набори, що враховують параметри та умови середовища, які впливають на поведінку функцій. Для кожної умови визначається безліч значень і обмежень предикатів, які тестуються.
Опишіть критерії вибору тестів. Визначте метрики тестування.
Критерії відбору тестів / критерії адекватності тестів, правила припинення тестування (Test selection criteria / test adequacy criteria, or stopping rules) Критерії відбору тестів можуть використовуватися як для створення набору тестів, так і для перевірки, наскільки вибрані тести адекватні вирішуваних завдань (тестування). При цьому, обговорювані критерії допомагають визначити, коли можна або необхідно припинити тестування.
Метрики підрахунку дефектів 7.2.2. Щільність дефектів (Fault density) Програма, що тестується, може оцінюватися на основі підрахунку та класифікації знайдених дефектів. Для кожного класу дефектів можна визначити відношення між кількістю відповідних дефектів і розміром програми (ви термінах обраних метрик оцінки розміру). 7.2.3. Метрики покриття й глибини тестування 7.3. Ключові питання 164 Життєвий цикл тестів, оцінка надійності (Life test, reliability evaluation) Статистичні очікування щодо надійності програмної системи можуть використовуватися для ухвалення рішення про продовження або припинення (закінчення) тестування, виходячи із заданих параметрів прийнятної якості (наприклад, щільності дефектів заданого класу). Моделі зростання надійності (Reliability growth models) Дані моделі забезпечують можливості прогнозування надійності системи, базуючись на виявлених збої. Моделі такого роду розбиваються на дві групи • - за кількістю збоїв (failure-count) і • часу між збоями (time-between-failure). Оцінка виконаних тестів (Evaluation of the tests performed) Метрики покриття / глибини тестування (Coverage / thoroughness measures) Критерії "адекватності" тестування, у ряді випадків, вимагають систематичного виконання тестів для певних набору елементів програми, що задаються її архітектурою або специфікацією. Відповідні метрики дозволяють оцінити ступінь охоплення характеристик системи (наприклад, відсоток тестованих різних параметрів продуктивності) і глибину їх деталізації (наприклад, випадкове тестування параметрів продуктивності або з урахуванням граничних значень і т.п.). Такі метрики допомагають прогнозувати розподіл усіх досягнення заданих параметрів якості системи.
Охарактеризуйте види тестування.
Модульне тестування (Unit testing) Цей рівень тестування дозволяє перевірити функціонування окремо взятого елемента системи. Що вважати елементом - модулем системи визначається контекстом. Найбільш повно даний вид тестів описаний у стандарті IEEE 1008-87 "Standard for Software Unit Testing", що задають інтегровану концепцію систематичного і документованого підходу до модульного тестування.
Всі види тестування програмного забезпечення, залежно від переслідуваних цілей, можна умовно розділити на наступні групи:
•	Функціональні (Functional testing)
•	Нефункціональні (Non-functional testing)
•	Пов’язані зі змінами (Regression testing)
Функціональні види тестування
Функціональні тести базуються на функціях і особливостях, а також взаємодії з іншими системами, і можуть бути представлені на всіх рівнях тестування: компонентному або модульному (Component / Unit testing), інтеграційному (Integration testing), системному (System testing) і приймальному (Acceptance testing ).
Функціональні види тестування розглядають зовнішню поведінку системи. Далі перераховані одні з найпоширеніших видів функціональних тестів:
Функціональне тестування (Functional testing)
Тестування безпеки (Security and Access Control Testing)
Тестування взаємодії (Interoperability Testing)
Нефункціональні види тестування
Нефункціональне тестування описує тести, необхідні для визначення характеристик програмного забезпечення, які можуть бути виміряні різними величинами. В цілому, це тестування того, “Як” система працює. Далі перераховані основні види нефункціональних тестів:
Всі види тестування продуктивності:
тестування навантаження (Performance and Load Testing)
стресове тестування (Stress Testing)
тестування стабільності або надійності (Stability / Reliability Testing)
об’ємне тестування (Volume Testing)
Тестування установки (Installation testing)
Тестування зручності користування (Usability Testing)
Тестування на відмову і відновлення (Failover and Recovery Testing)
Конфігураційне тестування (Configuration Testing)
Тестування, пов’язане зі змінами 
Після проведення необхідних змін, таких як виправлення бага / дефекту, програмне забезпечення повинне бути перетестоване для підтвердження того факту, що проблема була дійсно вирішена. Нижче перераховані види тестування, які необхідно проводити після установки програмного забезпечення, для підтвердження працездатності програми або правильності здійсненого виправлення дефекту:
Димове тестування (Smoke Testing)
Регресійне тестування (Regression Testing)
Тестування збірки (Build Verification Test)
Санітарне тестування або перевірка узгодженості / справності (Sanity Testing)
Дайте характеристику поняття базовий клас.
В об'єктно-орієнтованому програмуванні абстрактний клас – це базовий клас, від якого не можна створити екземпляру. На практиці абстрактні класи реалізують один з принципів ООП – поліморфізм. В абстрактному класі можна описати (або не визначити) абстрактні методи та властивості. Абстрактний метод не реалізовується в класі в якому описується, але має бути реалізований в неабстрактному нащадку. Абстрактні класи вважаються найбільшими узагальненими абстракціями, тобто відношення об'єму описів до об'єму реалізації найбільше. В деяких мовах заборонено створювати екземпляри абстрактних класів, в інших дозволяється (наприклад, Delphi), але звернення даного екземпляра, до абстрактного методу викличе помилку. В багатьох мовах дозволяється оголошувати будь який клас абстрактним навіть, якщо в ньому нема абстрактних методів (наприклад, Java). Для того щоб заборонити створення екземплярів. Абстрактний клас можна розглядати, як інтерфейс для сімейства класів, які ним породжені, але на противагу класичному інтерфейсу, абстрактний клас може містити реалізацію методів та властивості. Абстрактні методи переважно є і віртуальними, через це поняття «абстрактний» та «віртуальний» інколи плутають. Абстрактні класи відіграють важливу роль для статичної типізації в об’єктно-орієнтованих мовах. Багато динамічно типізованих мов не мають схожих механізмів (хоча використання латентної типізації відкидає потребу в абстрактних класах); а ще трейти, реалізацію яких можна знайти в сучасних динамічно типізованих мовах. Деякі програмісти стверджують, що класи повинні бути фінальними (без похідних), або абстрактним.
Абстрактні класи корисні тим, що за їхньою допомогою можна визначити протокол; набір операцій, які мають бути у всіх об'єктах, які реалізують протокол.
Дайте характеристику понять об'єкт, метод, клас.
Клас 
Клас визначає абстрактні характеристики деякої сутності, включаючи характеристики самої сутності (її атрибути або властивості) та дії, які вона здатна виконувати (її поведінки, методи або можливості). Наприклад, клас Собака може характеризуватись рисами, притаманними всім собакам, зокрема: порода, колір хутра, здатність гавкати. Класи вносять модульність та структурованість в об'єктно-орієнтовану програму. Як правило, клас має бути зрозумілим для не-програмістів, що знаються на предметній області, що, у свою чергу, значить, що клас повинен мати значення в контексті. Також, код реалізації класу має бути досить самодостатнім. Властивості та методи класу, разом називаються його членами.
Об'єкт 
Окремий екземпляр класу (створюється після запуску програми і ініціалізації полів класу). Клас Собака відповідає всім собакам шляхом опису їхніх спільних рис; об'єкт Сірко є одним окремим собакою, окремим варіантом значень характеристик.Собака має хутро; Сірко має коричнево-біле хутро. Об'єкт Сірко є екземпляром (примірником) класу Собака. Сукупність значень атрибутів окремого об'єкта називається станом. На основі класу Собака можна, також, створити інший об'єктДружок, який відрізнятиметься від об'єкта Сірко своїм станом (наприклад кольором хутра). Обидва об'єкта (Сірко і Дружок) є екземплярами класу Собака.
Метод 
Можливості об'єкта. Оскільки Сірко — Собака, він може гавкати. Тому гавкати() є одним із методів об'єкта Сірко. Він може мати й інші методи, зокрема: місце(), або їсти(). В межах програми, використання методу має впливати лише на один об'єкт; всі Собаки можуть гавкати, але треба щоб гавкав лише один окремий собака.
Охарактеризуйте основні і похідні атрибути.
Використовуючи математичну термінологію, властивість Property найпростішого об'єкта-атрибута Obj можна визначити як функцію від його атрибутів Atn, Atr2,.., Atrk як від змінних:
Obj.Property = F(Obj.Atr1, Obj.Atr2,..., Obj.Atrk)
Тому сукупність Atr1, Atr2, . . . , Atrk атрибутів об'єкта повинна задовольняти вимозі функціональної повноти.
Функціональна повнота набору атрибутів означає, що будь-яка властивість об'єкта може бути виражена у виді функції його атрибутів, що може бути обчислена.
Наприклад, атрибутами вектора на площині можуть бути його декартові координати, оскільки відомо, що будь-які інші характеристики і властивості векторів виражаються через їхні декартові координати
З властивістю функціональної повноти тісно пов'язана властивість незалежності набору атрибутів.
Набір атрибутів називають функціонально незалежним, якщо жоден з атрибутів цього набору не може бути обчисленими через інші атрибути.
Наприклад, набір атрибутів Day, Month, Year, WeekDay є функціонально залежним, оскільки день тижня WeekDay можна обчислити, знаючи значення Day, Month, Year.
Атрибути функціонально незалежного набору називають основними, а інші - похідними.
Як правило, у наборі всіляких даних, які можна розглядати як кандидатів в атрибути об'єкта, виділяють тільки функціонально незалежний набір. Дані цього набору визначають як атрибути, а інші дані реалізують як властивості, описуючи методи доступу до них у виді обчислень. Іноді, однак, має сенс доповнити функціонально незалежний набір атрибутів декількома похідними атрибутами, якщо це сильно вплине на якість програми (наприклад, дозволить різко збільшити її швидкодію). У цьому випадку реалізація методів-селекторів ускладнюється, оскільки в кожному з них потрібно реалізувати обчислення значень похідних атрибутів
Визначте принципи об’єктно-орієнтованого проектування.
Інкапсуляція - властивість мови програмування, що дозволяє користувачеві не замислюватися про складність реалізації використовуваного програмного компонента (що у нього всередині?), А взаємодіяти з ним за допомогою наданого інтерфейсу (публічних методів і членів), а також об'єднати і захистити життєво важливі для компонента дані. При цьому користувачеві надається тільки специфікація (інтерфейс) об'єкта. Користувач може взаємодіяти з об'єктом тільки через цей інтерфейс. Реалізується за допомогою ключового слова: public. Користувач не може використовувати закриті дані і методи. Реалізується за допомогою ключових слів: private, protected, internal. Інкапсуляція - один з чотирьох найважливіших механізмів об'єктно-орієнтованого програмування (поряд з абстракцією, поліморфізмом і спадкуванням). Приховування реалізації доцільно застосовувати в наступних випадках: гранична локалізація змін при необхідності таких змін, прогнозованість змін (які зміни в коді треба зробити для заданого зміни функціональності) і прогнозованість наслідків змін.
Абстракція - в об'єктно-орієнтованому програмуванні це додання об'єкту характеристик, які відрізняють його від всіх інших об'єктів, чітко визначаючи його концептуальні межі. Основна ідея полягає в тому, щоб відокремити спосіб використання складових об'єктів даних від деталей їх реалізації у вигляді простіших об'єктів, подібно до того, як функціональна абстракція розділяє спосіб використання функції і деталей її реалізації в термінах більш примітивних функцій, таким чином, дані обробляються функцією високого рівня за допомогою виклику функцій низького рівня. Такий підхід є основою об'єктно-орієнтованого програмування. Це дозволяє працювати з об'єктами, не вдаючись у особливості їх реалізації. У кожному конкретному випадку застосовується той чи інший підхід: інкапсуляція, поліморфізм або успадкування. Наприклад, при необхідності звернутися до прихованих даними об'єкта, слід скористатися инкапсуляцией, створивши, так звану, функцію доступу або властивість. Абстракція даних - популярна і в загальному невірно визначається техніка програмування. Фундаментальна ідея полягає в поділі несуттєвих деталей реалізації підпрограми і характеристик істотних для коректного її використання. Такий поділ може бути виражено через спеціальний «інтерфейс», зосереджують опис всіх можливих застосувань програми [1]. З точки зору теорії множин, процес являє собою організацію для групи підмножин свого безлічі. Див. Також Закон зворотного відносини між змістом і обсягом поняття.
Спадкування - один з чотирьох найважливіших механізмів об'єктно-орієнтованого програмування (поряд з инкапсуляцией, поліморфізмом і абстракцією), що дозволяє описати новий клас на основі вже існуючого (батьківського), при цьому властивості і функціональність батьківського класу запозичуються новим класом. Іншими словами, клас-спадкоємець реалізує специфікацію вже існуючого класу (базовий клас). Це дозволяє звертатися з об'єктами класу-спадкоємця точно так же, як з об'єктами базового класу. Просте наслідування: Клас, від якого відбулося спадкування, називається базовим або батьківським (англ. Base class). Класи, які походять від базового, називаються нащадками, спадкоємцями або похідними класами (англ. Derived class). Деякі мови використовують абстрактні класи. Абстрактний клас - це клас, який містить хоча б один абстрактний метод, він описаний в програмі, має поля, методи і не може використовуватися для безпосереднього створення об'єкта. Тобто від абстрактного класу можна тільки наслідувати. Об'єкти створюються тільки на основі похідних класів, успадкованих від абстрактного. Наприклад, абстрактним класом може бути базовий клас «співробітник вузу», від якого успадковуються класи «аспірант», «професор» і т. Д. Так як похідні класи мають спільні поля і функції (наприклад, поле «рік народження»), то ці члени класу можуть бути описані в базовому класі. У програмі створюються об'єкти на основі класів «аспірант», «професор», але немає сенсу створювати об'єкт на основі класу «співробітник вузу».
Поліморфізм - можливість об'єктів з однаковою специфікацією мати різну реалізацію. Мова програмування підтримує поліморфізм, якщо класи з однаковою специфікацією можуть мати різну реалізацію - наприклад, реалізація класу може бути змінена в процесі успадкування [1]. Коротко зміст поліморфізму можна виразити фразою: «Один інтерфейс, безліч реалізацій». Поліморфізм - один з чотирьох найважливіших механізмів об'єктно-орієнтованого програмування (поряд з абстракцією, инкапсуляцией і спадкуванням). Поліморфізм дозволяє писати більш абстрактні програми і підвищити коефіцієнт повторного використання коду. Загальні властивості об'єктів об'єднуються в систему, яку можуть називати по-різному - інтерфейс, клас. Спільність має зовнішнє і внутрішнє вираження: зовнішня спільність проявляється як однаковий набір методів з однаковими іменами та сигнатурами (ім'ям методів і типами аргументів і їх кількістю); внутрішня спільність - однакова функціональність методів. Її можна описати інтуїтивно або висловити у вигляді строгих законів, правил, яким повинні підкорятися методи. Можливість приписувати різну функціональність одному методу (функції, операції) називається перевантаженням методу (перевантаженням функцій, перевантаженням операцій).
Охарактеризуйте поняття  інкапсуляція.
Приховування деталей про роботу класів від об'єктів, що їх використовують або надсилають їм повідомлення. Так, наприклад, клас Собака має метод гавкати(). Реалізація цього методу описує як саме повинно відбуватись гавкання (приміром, спочатку вдихнути() а потім видихнути() на обраній частоті та гучності). Петро, хазяїн пса Сірка, не повинен знати як він гавкає. Інкапсуляція досягається шляхом вказування, які класи можуть звертатися до членів об'єкта. Як наслідок, кожен об'єкт представляє кожному іншому класу певний інтерфейс — члени, доступні іншим класам. Інкапсуляція потрібна для того, аби запобігти використанню користувачами інтерфейсу тих частин реалізації, які, швидше за все, будуть змінюватись. Це дозволить полегшити внесення змін, тобто, без потреби змінювати і користувачів інтерфейсу. Наприклад, інтерфейс може гарантувати, що щенята можуть додаватись лише до об'єктів класу Собака кодом самого класу. Часто, члени класу позначаються як публічні (англ. public), захищені (англ. protected) та приватні (англ. private), визначаючи, чи доступні вони всім класам, підкласам, або лише до класу в якому їх визначено. Деякі мови програмування йдуть ще далі: Javaвикористовує ключове слово private для обмеження доступу, що буде дозволений лише з методів того самого класу, protected — лише з методів того самого класу і його нащадків та з класів із того ж самого пакету, C# та VB.NET відкривають деякі члени лише для класів із тієї ж збірки шляхом використання ключового слова internal (C#) або Friend (VB.NET), а Eiffel дозволяє вказувати які класи мають доступ до будь-яких членів.
Що таке технологія Token Ring?
Token Ring - технологія локальної обчислювальної мережі (LAN) кільця з «маркерним доступом» - протокол локальної мережі, який знаходиться на канальному рівні (DLL) моделі OSI. Він використовує спеціальний трёхбайтовий фрейм, названий маркером, який переміщається навколо кільця. Володіння маркером надає його власнику право передавати інформацію на носії. Кадри кільцевої мережі з маркерним доступом переміщаються в циклі.
Станції на локальної обчислювальної мережі (LAN) Token Ring логічно організовані в кільцеву топологію з даними, переданими послідовно від однієї кільцевої станції до іншої з керуючим маркером, що циркулює навколо кільцевого доступу управління. Цей механізм передачі маркера спільно використаний ARCNET, маркерношіной, і FDDI, і має теоретичні переваги перед стохастическим CSMA / CD Ethernet. Максимальний розмір корисного блоку даних (MTU) 4464 байта
Token Ring і IEEE 802.5 є головними прикладами мереж з передачею маркера. Мережі з передачею маркера переміщують по мережі невеликої блок даних, званий маркером. Володіння цим маркером гарантує право передачі. Якщо вузол, який приймає маркер, не має інформації для відправки, він просто переправляє маркер до наступної кінцевої станції. Кожна станція може утримувати маркер протягом певного максимального часу (за замовчуванням - 10 мс).
Дана технологія пропонує варіант вирішення проблеми колізій, яка виникає при роботі локальної мережі. В технології Ethernet такі колізії виникають при одночасній передачі інформації декількома робочими станціями, що знаходяться в межах одного сегмента, тобто використовують загальний фізичний канал даних.
Якщо у станції, що володіє маркером, є інформація для передачі, вона захоплює маркер, змінює у нього один біт (в результаті чого маркер перетворюється в послідовність «початок блоку даних»), доповнює інформацією, яку він хоче передати, і відсилає цю інформацію до наступної станції кільцевої мережі. Коли інформаційний блок циркулює по кільцю, маркер в мережі відсутня (якщо тільки кільце не забезпечує «раннього звільнення маркера» - early token release), тому інші станції, які бажають передати інформацію, змушені очікувати. Отже, в мережах Token Ring не може бути колізій. Якщо забезпечується раннє вивільнення маркера, то новий маркер може бути випущений після завершення передачі блоку даних.
Інформаційний блок циркулює по кільцю, поки не досягне передбачуваної станції призначення, яка копіює інформацію для подальшої обробки. Інформаційний блок продовжує циркулювати по кільцю; він остаточно видаляється після досягнення станції, відіслав цей блок. Станція відправлення може перевірити повернувся блок, щоб переконатися, що він був переглянутий і потім скопійований станцією призначення.
Що таке фізичний рівень моделі OSI? Коротко охарактеризуйте його.
Фізичний шар (англ. Physical layer) або фізичний рівень - перший рівень мережевої моделі OSI. Це нижній рівень моделі OSI - фізична і електрична середовище для передачі даних. Фізичний рівень визначає методи передачі біт (а не пакетних даних) через фізичні середовища ліній зв'язку, що з'єднують мережеві пристрої. На цьому рівні описуються параметри сигналів, такі як амплітуда і частота, використовувана модуляція і інші низькорівневі параметри.
Якщо подивитися з тієї точки зору, що мережа включає в себе обладнання та програми, які контролюють обладнання, то тут фізичний шар буде ставитися саме до першої частини визначення.
Цей рівень, так само як канальний і мережевий, є Мережезалежні.
Одиниця виміру, яка використовується на цьому шарі - Біти, тобто фізичний рівень передає радіосигнали потоку бітів по відповідній фізичній середовищі через відповідний інтерфейс.
Технічні засоби [ред | правити вікі-текст]
Кабель (коаксіальний, вита пара, оптоволоконний, бездротова середа).
Роз'єм (наприклад 8P8C).
Комутаційна панель.
Плінт.
Повторювач сигналів.
Багатопортові повторювачі або концентратори.
Перетворювачі середовища або медиаконвертери (transceiver).
MAU (Media Access Unit).
Мережевий адаптер (NIC) - він також задіяний і на канальному рівні.
Що таке технологія Ethernet?
Ethernet - «ефір» і англ. Network - «мережа, ланцюг») - сімейство технологій пакетної передачі даних для комп'ютерних мереж.
Стандарти Ethernet визначають кабельні з'єднання і електричні сигнали на фізичному рівні, формат кадру та протоколи управління доступом до середовища - на канальному рівні моделі OSI. Ethernet в основному описується стандартами IEEE групи 802.3. Ethernet став найпоширенішою технологією ЛВС в середині 1990-х років, витіснивши такі застарілі технології, як ARCNET і Token ring.
Назва «Ethernet» (буквально «ефірна мережа» або «середовище мережі») відображає первісний принцип роботи цієї технології: все, що передається одним вузлом, одночасно приймається всіма іншими (тобто є якась схожість з радіомовленням). В даний час практично завжди підключення відбувається через комутатори (switch), так що кадри, що відправляються одним вузлом, доходять лише до адресата (виняток становлять передачі на широкомовна адресу) - це підвищує швидкість роботи і безпеку мережі. У стандарті перших версій (Ethernet v1.0 і Ethernet v2.0) вказано, що в якості середовища використовується коаксіальний кабель, надалі з'явилася можливість використовувати виту пару і оптичний кабель.
Переваги використання кручений пари в порівнянні з коаксіальним кабелем:
можливість роботи в дуплексному режимі;
низька вартість кабелю кручений пари;
більш висока надійність мереж: при використанні кручений пари мережа будується по топології «зірка», тому обрив кабелю призводить лише до порушення зв'язку між двома об'єктами мережі, з'єднаними цим кабелем (при використанні коаксіального кабелю мережа будується по топології «загальна шина», для якої потрібно наявність термінальних резисторів на кінцях кабелю, тому обрив кабелю призводить до несправності сегмента мережі);
зменшений мінімально допустимий радіус вигину кабелю;
велика стійкість через використання диференціального сигналу;
можливість живлення по кабелю малопотужних вузлів, наприклад, IP-телефонів (стандарт Power over Ethernet, PoE);
гальванічна розв'язка трансформаторного типу. В умовах СНД, де, як правило, відсутня заземлення комп'ютерів, застосування коаксіальногокабелю часто призводило до виходу з ладу мережевих карт в результаті електричного пробою.
Причиною переходу на оптичний кабель була необхідність збільшити довжину сегмента без повторювачів.
Метод управління доступом (для мережі на коаксіальному кабелі) - множинний доступ з контролем несучої і виявленням колізій (CSMA / CD, Carrier Sense Multiple Access with Collision Detection), швидкість передачі даних 10 Мбіт / с, розмір кадру від 64 до 1518 байт, описані методи кодування даних. Режим роботи напівдуплексний, тобто вузол не може одночасно передавати і приймати інформацію. Кількість вузлів в одному сегменті мережі обмежено граничним значенням в 1024 робочих станції (специфікації фізичного рівня можуть встановлювати жорсткіші обмеження, наприклад, до сегменту тонкого коаксиала може підключатися не більше 30 робочих станцій, а до сегменту товстого коаксиала - не більше 100). Проте мережа, побудована на одному сегменті, стає неефективною задовго до досягнення граничного значення кількості вузлів, в основному через полудуплексного режиму роботи.
У 1995 році прийнятий стандарт IEEE 802.3u Fast Ethernet зі швидкістю 100 Мбіт / с і з'явилася можливість роботи в режимі повний дуплекс. У 1997 році був прийнятий стандарт IEEE 802.3z Gigabit Ethernet зі швидкістю 1000 Мбіт / с для передачі через оптичне волокно і ще через два роки для передачі по кручений парі.
Переводчик Google для бизнеса –Инструменты переводчикаПереводчик сайтовСлужба "Анализ рынков"
Яка структура ІР пакету?
Структура IP-пакету
Вище ми розглянули як пакети третього рівня стають даними другого рівня та інкапсулюються у фрейми. Аналогічно, IP-пакети складаються з даних верхнього рівня та IP-заголовку. За специфікацією протоколу, пакет має бути не більший за 65535 бітів (з заголовком та даними включно).
•	Версія (Version) — 4-бітове поле, що описує використовувану версію протоколу IP. Всі пристрої зобов'язані використовувати протокол IP однієї версії, пристрій що використовує іншу версію буде відкидати пакети.
•	Довжина IP-заголовку (IP header Length — HLEN) — 4-бітове поле, що описує довжину заголовку пакету в 32-бітових блоках. Це значення — це повна довжина заголовку з врахуванням двох полів змінної довжини.
•	Тип обслуговування (Type of Service — TOS) — 8-бітове поле, що вказує на ступінь важливості інформації, що привласнена протоколом верхнього рівня.
•	Загальна довжина (Total Length) — 16-бітове поле, що описує довжину пакету в байтах, із заголовком та даними включно. Для того щоб вирахувати довжину блока даних, потрібно від повної довжини відняти значення поля HLEN.
•	Ідентифікація (Identification) — шістнадцятибітове поле, що зберігає ціле число, яке описує даний пакет. Це число являє собою послідовний номер.
•	Прапорці (Flags) — 3-бітове поле, в якому два молодших біта контролюють фрагментацію пакетів. Перший біт визначає чи було пакет фрагментовано, а другий чи є цей пакет останнім фрагментом в серії фрагментів.
•	Зміщення фрагментації (Fragment Offset) — 13-бітове поле, що допомагає зібрати разом фрагменти пакетів. Це поле дозволяє використовувати 16 бітів в сумі для прапорів фрагментації.
•	Час життя (Time-to-Live — TTL) — 8-бітове поле — лічильник, в якому зберігаються послідовно зменшуване значення кількості пройдених вузлів (роутерів, що їх ще іноді в цьому випадку називають хопами (hops)) на шляху до місця призначення. У випадку коли лічильник пройдених хопів дорівнюватиме нулю — пакет буде відкинуто, таким чином попереджується нескінченна циклічна пересилка пакетів.
•	Протокол (Protocol) — 8-бітове поле, що вказує на те, який протокол верхнього рівня отримає пакет, після завершення обробки IP-протоколом. Наприклад TCP або UDP.
•	Контрольна сума заголовку (Header Checksum) — 16-бітове поле, що допомагає перевірити суцільність заголовку пакету.
•	IP-адреса відправника (Source IP address) (адресант, сорс, відправник) — 32-бітове поле, що зберігає IP-адресу вузла-відправника.
•	IP-адреса отримувача (Destination IP adress) (адресат, дест, отримувач) — 32-бітове поле, що зберігає адресу вузла призначення (отримувача).
•	Опції (Options) — поле змінної довжини, що дозволяє протоколу IP реалізувати підтримку різних опцій, зокрема засобів безпеки.
•	Підкладка (Padding) — поле, що використовується для вставки додаткових нулів, для гарантування кратності IP-заголовку 32 бітам.
•	Дані (Data) — поле змінної довжини (64 Кбіт макс.), що зберігає інформації для верхніх рівнів.

Біти 0-3	4-7	8-15	16-18	19-23	24-31
Версія	HLEN	Тип обслуговування	Загальна довжина
Ідентифікація	Прапорці	Зміщення фрагментації
Час життя	Протокол	Контрольна сума заголовку
IP-адреса відправника
IP-адреса отримувача
Опції	Додаток
Дані (65535 мінус заголовок)
…
IP-пакет складається з даних протоколу верхнього рівня і заголовку, що має описану вище структуру. Хоча основною частиною заголовку є адреси відправника і призначення, саме інші частини заголовку роблять протокол таким надійним і гнучким. Інформація, що зберігається в полях заголовку задає дані пакету і призначена для протоколів верхніх рівнів.
Які основні функції протоколу ІР?
Протокол IP є найголовнішим у всій ієрархії протоколів сімейства TCP / IP. Саме він використовується для управління розсилкою TCP / IP пакетів по мережі Internet. Серед різних функцій, покладених на IP зазвичай виділяють наступні:
визначення пакету, який є базовим поняттям і одиницею передачі даних в мережі Internet. Багато зарубіжні автори називають такий IP-пакет датаграммой;
визначення адресному схеми, яка використовується в мережі Internet;
передача даних між канальним рівнем (рівнем доступу до мережі) і транспортним рівнем (іншими словами мультиплексування транспортних датаграмм у фрейми канального рівня);
маршрутизація пакетів по мережі, тобто передача пакетів від одного шлюзу до іншого з метою передачі пакета машині-одержувачу;
"Нарізка" і складання з фрагментів пакетів транспортного рівня.
Головними особливостями протоколу IP є відсутність орієнтації на фізичне або віртуальне з'єднання. Це означає, що перш ніж послати пакет в мережу, модуль операційної системи, який реалізує IP, не перевіряє можливість установки з'єднання, тобто ніякої керуючої інформації крім тієї, що міститься в самому IP-пакеті, по мережі не передається. Крім цього, IP не дбає про перевірку цілісності інформації в поле даних пакета, що змушує віднести його до протоколів ненадійної доставки. Цілісність даних перевіряється протоколами транспортного рівня (TCP) або протоколами додатків.
Таким чином, вся інформація про шляхи, по якому повинен пройти пакет береться із самої мережі в момент проходження пакета. Саме ця процедура і називається маршрутизацією на відміну від комутації, яка використовується для попереднього встановлення маршруту проходження даних, за яким потім ці дані відправляють

